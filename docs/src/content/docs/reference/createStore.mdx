---
title: createStore
description: createStore - API Reference
sidebar:
    order: 1
---
import { Aside } from '@astrojs/starlight/components'

Function that creates a store.

You can think of a store as your app state. You can define multiple keys/values, each key will create separated subscription ([more explained here](#useStore)). If you want to persist the value - you can simply wrap it in [Synchronizer](../synchronizer)

It can be imported from `stan-js` or  from `stan-js/vanilla` you can read more about usage with vanilla-js [here](../vanilla)

```ts
import { createStore } from 'stan-js'

export const { actions, getState, reset, effect, useStore, useStoreEffect } = createStore({
    count: 0,
    name: 'John',
    notifications: [] as Array<Notification>
})
```

## createStore returns such things:
- [actions](#actions)
- [getState](#getState)
- [reset](#reset)
- [effect](#effect)
- [useStore](#useStore)
- [useStoreEffect](#useStoreEffect)
- [batchUpdates](#batchUpdates)

### actions

Object that contains all functions that allows for updating the store's state

Action name is generated automatically based on given key to the store ``count -> setCount``

You can pass the next state directly, or a function that calculates it from the previous state - similary to the ``useState`` hook

### getState

Function that returns current state of the store

```typescript
const { count } = getState()

console.log(count)
```

### reset

Function that resets store state to the initial values

You can either pass all of the keys that you want to be reset, or if you won't pass any key **WHOLE** store will be reseted.

```typescript
reset('count')
// Only count value will be reseted

reset('name', 'notifications')
// name and notifications will be reseted

reset()
// Whole store will be reseted
```

### effect

Function that allows to subscribe to store's values change and react to them

It takes callback with current store's state that will be triggered on every store's value that you are using

```typescript
const dispose = effect(({ count }) => {
    console.log(count)
})
```

<Aside type="caution">
You **should** destructure values from this hook - to let the store know what values you will access

It **ONLY** triggers the callback if the values that we have accessed changed

You can read more about it [here](../../reference/destructure)
</Aside>

### useStore

React's hook that allows to access store's values and to update them

```typescript
const { count, setCount, setName } = useStore()

console.log(count)

setCount(prev => prev + 1) // Component will rerender
setName('Anna') // Component won't rerender because it doesn't subscribe to name
```

<Aside type="caution">
You **should** destructure values from this hook - to let the store know what values you will access

It **ONLY** rerenders the component if the values that we have accessed changed

You can read more about it [here](../../reference/destructure)
</Aside>

### useStoreEffect

React's hook that uses [effect](#effect) under the hood

You should use it inside React components, and in the other places feel free to use ``effect``

```typescript
useStoreEffect(({ count }) => {
    console.log(count)
})
```

<Aside type="caution">
You **should** destructure values from this hook - to let the store know what values you will access

It **ONLY** triggers the callback if the values that we have accessed changed

You can read more about it [here](../../reference/destructure)
</Aside>

## Computed (derived) state

You can create computed value based on another value in store by using getter:

```typescript
export const { useStore } = createStore({
    counter: 0,
    get doubleCounter() {
        return this.counter * 2
    },
    get counters() { 
        return `${this.counter} is two times smaller than ${this.doubleCounter}`
    }
})
```

Now, whenever value of `count` changes `doubleCounter` will be recalculated. You can even create derived state from derived state!

<Aside type="note">
Action for computed state won't be generated by store, so the only way to change it is to update value that it depends on.
</Aside>

<Aside type="caution">
It **ONLY** recalculates the value if the values that we have accessed changed

You can read more about it [here](../../reference/destructure)
</Aside>

### batchUpdates

Function that allows to batch updates to the store's state

```typescript
const { batchUpdates, effect, actions } = createStore({
    firstName: 'John',
    lastName: 'Doe',
})

effect(({ firstName, lastName }) => {
    console.log(`${firstName} ${lastName}`)
})

actions.setFirstName('Jane')
// console.log: Jane Doe
actions.setLastName('Bar')
// console.log: Jane Bar

batchUpdates(() => {
    actions.setFirstName('Mark')
    actions.setLastName('Smith')
    // console.log: Mark Smith
})
```

<Aside type="note">
You should keep this function in mind when you are using it with effect or useStoreEffect

In useStore hook it will be autobatched by React useSyncExternalStore hook
</Aside>
